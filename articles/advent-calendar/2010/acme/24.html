<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="description" content="">
        <meta name="author" content="yappo">
        <title>dan.pm に迫る - Articles Advent Calendar 2010 Acme</title>
        <link rel="icon" href="/img/favicon.ico">
        <link rel="canonical" href="https://perl-users.jp/articles/advent-calendar/2010/acme/24">
        <link href="TODO" rel="stylesheet">
    </head>
    <body>
        <h1>dan.pm に迫る</h1>
        tag
            <a href='/tag/perl'>perl</a>
            <a href='/tag/acme'>acme</a>
            <a href='/tag/dankogai'>dankogai</a>

        <p><a href="http://atnd.org/events/10336"><img src="http://gyazo.com/9fd86dce549f1851c38bbe4ad77988f5.png" width="400" /></a></p><p>こんにちわ。前日に PerlIO ネタが出てきたので、ここぞとばかりに dan.pm を登場させましょう。</p><p>dan.pm とは何をするためのモジュールかというと、特定のレキシカルスコープの文字リテラルを無効化したりフィルタを噛ます事が出来るプラグマモジュールです。簡単にいうと空気を読まなかったり空気を読み替えます。<br />
Acme::dan とかになってないですが、プラグマなので dan としました。れっきとした Acme の一員です。</p>

<div class="section">
    <h4>dan を入れよう</h4>
    <p>dan は既に CPAN レディなので普通に cpanm で入れられます。</p>

    <pre class="code prettyprint">$ cpanm dan
--&gt; Working on dan
Fetching http://search.cpan.org/CPAN/authors/id/Y/YA/YAPPO/dan-0.551.2.tar.gz ... OK
Configuring dan-0.551.2 ... OK
Building and testing dan-0.551.2 ... OK
Successfully installed dan-0.551.2</pre>
<p>簡単に入りました！</p><p>ちなみにバージョン番号の 551 はコガイという意味です。</p>

</div>
<div class="section">
    <h4>dan を使おう</h4>
    <p>使い方はとっても簡単で</p>

    <pre class="code prettyprint lang-perl">use strict;
use warnings;
use feature &#39;say&#39;;

say &#39;俺が&#39;;
{
    use dan;
    say &#39;dan&#39;;
}
say &#39;だ！&#39;;</pre>
<p>のようにかくと</p>

<blockquote >
    <p>俺が</p><p>だ！</p>

    
</blockquote><p>と表示されます。</p>

</div>
<div class="section">
    <h4>dan に迫る</h4>
    <p>さて、このなんの変哲も無いネタモジュールですが内部的には普通やらない事をやってたりしてます。</p>

<ul>
<li>hinthash を使いプラグマを実装する</li>
<li>デフォルトのエンコーディング処理を乗っ取る</li>
</ul><p>では、順繰りにどうなってるか説明しましょう。じゃーん★</p>

</div>
<div class="section">
    <h4>hinthash の件</h4>
    <p>perl 5.10 から、ユーザが誰でもプラグマを実装出来るように、その実装をするために必要な %^H が整備されてます。 5.8 の時代からあったんですが、気軽に使えるような状況ではなかったんですね。</p><p>もう必要な所だけ説明すると BEGIN フェーズ(例えば import/unimport)の時に %^H を操作しておいて、あとから caller() を読んだ時に、 caller() を読んだスコープの中での hintash の内容が取得できるという、説明すると面倒なのでコードを貼ると</p>

    <pre class="code prettyprint lang-perl">package yappo {
    use strict;
    use warnings;

    my $HINT_LOCALIZE_HH = 0x20000;
    sub import {
        $^H{yappo} = 1;
    }
    sub unimport {
        delete $^H{yappo};
    }

    sub is_hentai {
        my $hinthash = (caller(0))[10];
       return !!$hinthash-&gt;{yappo};
    }
}
1;</pre>
<p>こういった yappo.pm というモジュールを用意しておいて</p>

    <pre class="code prettyprint lang-perl">use common::sense;
require yappo;

say yappo::is_hentai() ? &#39;hentai&#39; : &#39;normal&#39;;

{
    use yappo;
    say yappo::is_hentai() ? &#39;hentai&#39; : &#39;normal&#39;;
    no yappo;
    say yappo::is_hentai() ? &#39;hentai&#39; : &#39;normal&#39;;
    use yappo;
    say yappo::is_hentai() ? &#39;hentai&#39; : &#39;normal&#39;;
}

say yappo::is_hentai() ? &#39;hentai&#39; : &#39;normal&#39;;</pre>
<p>こんなコードを書いて実行すると。</p>

<blockquote >
    <p>normal<br />
hentai<br />
normal<br />
hentai<br />
normal</p>

    
</blockquote><p>と表示されます。</p><p>この import/unimport で操作してる %^H というのは BEGIN フェーズを抜けると適当な値になってしまうので、そのままでは使えないのですが、 (caller(0))[10] と perl 5.10 から新しく用意された caller の戻り値を使う事で、 caller が呼ばれたコードのスコープでの BEGIN フェーズ時のヒントハッシュの中身が取れるようになります。</p><p>BEGIN フェーズでコードを実行するお手軽でかつスマートな方法は import/unimport を実装しつつ use/no を使う事なので、これらのメソッドでヒントハッシュを操作しておいて、通常の実行フェーズでヒントハッシュを取り出せばプラグマが実行出来るという寸法です。</p><p>しかも、この方法でヒントハッシュを取り扱うと意識しなくてもヒントハッシュの中身がレキシカルスコープを意識した物になってるので、俺様プラグマが簡単に作れるって事ですね。</p><br />
<p>dan.pm はちゃんとしたプラグマモジュールとして実装されてる秘密は、このヒントハッシュをきちんと使ってるからってことですねぇ。</p>

</div>
<div class="section">
    <h4>エンコーディング処理を乗っ取る</h4>
    <p>まったくもって今や使うべきでは無いものなんですが</p>

    <pre class="code prettyprint lang-perl">use encoding &#34;euc-jp&#34;
my $text = &#39;にほんご&#39;;</pre>
<p>とかすると、文字リテラルを euc-jp として decode してから $text に自動的に定義するようになります。</p><p>dan.pm では、これを行うための仕組みに悪ふざけをして文字リテラルの読み込み処理に細工を施しています。</p>

<div class="section">
    <h5>文字リテラル読み込みを行うクラスを奪う</h5>
    <p>${^ENCODING} という特殊変数に、文字リテラルを読み込むためのインスタンスを入れると、それ以後の文字列読み取り処理がそのインスタンスを介して行われるようになります。</p><p>たとえば dan.pm ではだいたい以下のような事をしてます。</p>

    <pre class="code prettyprint lang-perl">${^ENCODING} = bless {}, &#39;dan&#39;;</pre>

</div>
<div class="section">
    <h5>必要なメソッドを用意する</h5>
    <p>文字リテラルを読み込むために必要な事として name/decode/cat_decode というメソッドを用意します。</p>

</div>
</div>
<div class="section">
    <h3>*** name</h3>
    <p>そのエンコーディングを処理するクラスで扱うエンコーディングの名前を返します。</p><p>dan.pm は面倒いので iso-8859-1 として処理します。</p>

</div>
<div class="section">
    <h3>*** decode</h3>
    <p>割愛</p>

</div>
<div class="section">
    <h3>*** cat_decode</h3>
    <p>実際に文字列を変換する処理を入れます。<br />
文字列の開始位置や、終端クオートやらもろもろのパラメータが渡されますので、良い感じに decode 処理してやってください。</p>

<div class="section">
    <h5>エンコーディング処理そのほか</h5>
    <p>いたるところで $self->is_dan としてますが、これを調べる事により「今処理しようとしている文字リテラルのスコープで dan が有効かどうか」をヒントハッシュを使って調べてます。 dan の範囲外だったら、もともとあったエンコーディング処理に丸投げします。</p><p>そのほか詳しい事は perldoc Encode::Encoding だけど、そもそもこの仕組みは今はもう真面目に使わない方がいいよ。</p>

</div>
<div class="section">
    <h4>おわりに</h4>
    <p>ということで何とか acme トラック書くことできました。みなさんすいません＞＜</p><p>see also: <a href="http://coderepos.org/share/browser/docs/yappo/20080515-yapcasia2008/yapcasia2008-hintshash.pl">Let's enjoy Perl on the %^H</a></p><p>あ、 yappo 提供の記事でした＾＾</p>

</div>
</div>
        <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=css&amp;skin=sunburst"></script>
    </body>
</html>
