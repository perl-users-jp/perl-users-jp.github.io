<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="description" content="">
        <meta name="author" content="lestrrat">
        <title>テストのためにデーモンを自動的に起動するやりかた2011年版 - Articles Advent Calendar 2011 Test</title>
        <link rel="icon" href="/img/favicon.ico">
        <link rel="canonical" href="https://perl-users.jp/articles/advent-calendar/2011/test/18">
        <link href="TODO" rel="stylesheet">
    </head>
    <body>
        <h1>テストのためにデーモンを自動的に起動するやりかた2011年版</h1>
        tag
            <a href='/tag/perl'>perl</a>
            <a href='/tag/test'>test</a>
            <a href='/tag/prove'>prove</a>

        
<div class="section">
    <h4>はじまりはパクり</h4>
    <p>最近あんまりコード書いてません、lestrratです。</p><p>テストを走らせる時にいろんな他のデーモンを立ち上げたり、そのテストのためだけの設定を先にしないといけなかったりとか色々ありますよね。結構長い間Makefile.PLはModule::Installで書いていたせいもあって、ちょっと前にxaicronさんが書いてたModule::Install::TestTargetでごにょごにょやってたのですが、ちょっと前にYappo/tokuhiromさんがproveで書いてたセットアップがまるっと自分の欲しい用途にも使える事に気づいたのでいろんなアプリケーションのテストをそのように変えてみました。</p>

</div>
<div class="section">
    <h4>流れ</h4>
    <p>proveでテストをすると、proveのプラグインを呼び出す設定ができるのですが、これをプラグインというよりテスト前に実行されるフックとして利用する事によって任意の設定用のコードを実行してしまおう、というのが目的です。</p><p>プラグインを使う際proveでは-Pスイッチを使って指定します：</p>

    <pre class="code prettyprint"># イメージ
prove -P MyPlugin1 -P MyPlugin2 ...</pre>
<p>ですがこのようにオプションが何個も連なるとどのオプションをどの順番に設定するのかすぐ忘れてしまいますし、プロジェクト内の他の人に実行してもらう時に説明しなければいけなくなってよくないですね。これを回避するために rcファイルを設定します。</p><p>rcfileに書いてある内容は全てproveへの引数として適用されますので、rcファイルだけ渡せばOKになります。</p>

    <pre class="code prettyprint">prove --rc=/path/to/rcfile</pre>
<p>これは簡単！そしてもう--rcさえ入力したくなければ、rcfileをプロジェクトのトップディレクトリに.provercという名前で保存しておけば自動的にそれを読み込んでくれます。</p>

</div>
<div class="section">
    <h4>プラグイン</h4>
    <p>prove -Pでプラグインを指定すると、該当パッケージ内のload() 関数が呼び出されます。</p><p>なので例えば以下のようなプラグインを実装しておけばテストを実行した時間を表示することができます：</p>

    <pre class="code prettyprint lang-perl">package MyTest::Timer;
use strict;

sub load {
    print STDERR &#34;Starting test at @{[ scalar localtime ]}\n&#34;;
}

1;</pre>

    <pre class="code prettyprint">prove -PMyTest::Timer ...
Starting test at Sun Dec 18 16:52:14 2011
...</pre>
<p>もうちょっと工夫すれば、テスト終了時の時刻も表示することができます：</p>

    <pre class="code prettyprint lang-perl">package MyTest::Timer;
use strict;
use Scope::Guard qw(guard);

my $TIMER;

sub load {
    print STDERR &#34;Starting test at @{[ scalar localtime ]}\n&#34;;
    $TIMER = guard { 
        print STDERR &#34;Ending test at @{[ scalar localtime ]}\n&#34;;
    };
}

# Global destruction... とか言われないためのハック
END {
    undef $TIMER;
}

1;</pre>

</div>
<div class="section">
    <h4>MySQLを自動的に開始する</h4>
    <p>ということでもう想像が付くとは思いますが、mysqldを自動的にTest::mysqld経由で開始してみましょう</p>

    <pre class="code prettyprint lang-perl">package MyTest::mysqld;
use strict;
use Test::mysqld;
use Test::More;

my $MYSQLD;

sub load {
    if (my $dsn = $ENV{TEST_DSN}) {
        diag &#34;TEST_DSN explicitly set. Not starting MySQL&#34;;
        return;
    }

    $MYSQLD = Test::mysqld-&gt;new(
        my_cnf =&gt; {
            &#34;skip-networking&#34; =&gt; &#34;&#34;
        }
    );

    $ENV{TEST_DSN} = $MYSQLD-&gt;dsn;
}

END { undef $MYSQLD }

1;</pre>
<p>これを仕込んでおきデータベース接続する部分の設定で $ENV{TEST_DSN}を読み込むようにすればこのデータベースを使ってテストができます。必要であればスキーマも流し込んでおくと良いでしょう。</p><p>Test::mysqldはインスタンスへのリファレンスをなくしさえすれば自動的にmysqldを停止してくれますので、$MYSQLDをパッケージレベルで保存しておけばテスト中はずっとmysqldは動作しています。ENDは無くても動きますが、なんとなくつけてみました。</p><p>というわけでこれを以下のように-Pで呼び出せるようにしておけばmysqldを使うテストもprove経由で簡単に書けますね</p>

    <pre class="code prettyprint">prove -PMyTest::mysqld ...</pre>

</div>
<div class="section">
    <h4>Memcachedもついでに開始</h4>
    <p>同じようにmemcachedも簡単に開始できます。</p>

    <pre class="code prettyprint lang-perl">package MyTest::memcached;
use strict;
use Test::More;
use Test::TCP;

our @MEMCACHED;

sub load {
    diag &#34;Checking for explicit TEST_MEMCACHED_SERVERS&#34;;
    # do we have an explicit memcached somewhere?
    if (my $servers = $ENV{TEST_MEMCACHED_SERVERS}) {
        return;
    }

    my $max = $ENV{TEST_MEMCACHED_COUNT} || 3;
    for my $i (1..3) {
        push @MEMCACHED, Test::TCP-&gt;new(code =&gt; sub {
            my $port = shift;
            diag &#34;Starting memcached $i on 127.0.0.1:$port&#34;;
            exec &#34;memcached -l 127.0.0.1 -p $port&#34;;
        });
    }

    $ENV{TEST_MEMCACHED_SERVERS} = join &#34;,&#34;,
        map { &#39;127.0.0.1:&#39; . $_-&gt;port } @MEMCACHED;
}

END { undef @MEMCACHED }

1;</pre>
<p>テスト内では Cache::Memcached/Cache::Memcached::Fast のコンストラクタにmemcachedサーバーの情報を渡せばmemcached混みのテストを書けます。</p>

    <pre class="code prettyprint lang-perl">Cache::Memcached-&gt;new({
    servers =&gt; [ split /, /, $ENV{TEST_MEMCACHED_SERVERS} ]
});</pre>
<p>proveからは以下のように呼び出せばよいだけです。</p>

    <pre class="code prettyprint">prove -PMyTest::mysqld -PMyTest::memcached ...</pre>

</div>
<div class="section">
    <h4>Makefile.PL で make testとフック</h4>
    <p>あとはproveでもmakeでもどっちでも同じように動くよう仕掛けをしておけばよいです。ここでは t/provercというファイルにproveを実行するのに必要な情報を保存してあると仮定します：</p>

    <pre class="code prettyprint"># t/proverc
# 本当は --lib か --blib を指定してライブラリへのパスを設定する必要があります
-PMyTest::memcached
-PMyTest::mysqld</pre>
<p>ここではプラグイン関連の設定しかしていませんが、各自必要な設定をここにいれておいてください。そしてmake testから何がよばれるのかをフックするには以下のような関数を指定しておけばいいだけです。</p>

    <pre class="code prettyprint lang-perl"># Makefile.PL

sub MY::test_via_harness { &#34;\tprove --rc=t/proverc t\n&#34; }

# Module::InstallだったらWriteAll()
# ExtUtils::MakeMakerだったらWriteMakefile(...)</pre>
<p>これで make testを実行した時にproveが実行され、その際にmysqldおよびmemcachedが起動されます。</p>

</div>
<div class="section">
    <h4>まとめ</h4>
    <p>proveのプラグインを使うとPerlのリファレンスカウンティングを使って上記のようなデーモンのライフサイクルをテスト実行時にだけ限定することが可能です。</p><p><a href="http://stf-storage.github.com/">STF</a>などのアプリケーションもこの方式に変えました。Jenkinsに入れる時にJUnitやカバレッジ用のプラグインとの連携もこれで楽になりましたのでおすすめですね。</p><p>あと個人的には .provercに保存するより、t/provercのようなファイルに入れておく方が<br />
小回りが利いて好きですが、ここは個人的な好みが入ってくるところかもしれません。.provercを使う場合はこのファイルがあると＊必ずprovercの中身が適用される＊ということを覚えておいてください。例えば mysqldを必要としてないテストだけを実行したい場合などでも.provercを使った場合は強制的にmysqldが起動されますが、他のファイルにしておくといつprovercの内容を適用するのか選べるので自分は好きです。</p><p>このやり方をさらに進めていけば、テスト時だけ起動するモックRPCサーバーの起動や、フィクスチャーの設定などもできますので色々試してみるといいかもしれません。</p><p>prove on!</p>

</div>
        <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=css&amp;skin=sunburst"></script>
    </body>
</html>
